## ðŸ”¥ JAWABAN PERTANYAAN UTAMA LU

> **â€œKenapa pakai `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`
> padahal tanpa itu hasilnya sama?â€**

### âœ… Jawaban pendek (penting):

Karena **ORDER BY + window function punya default frame = RANGE**,
dan **dalam kasus tertentu kebetulan hasilnya sama**, tapi **secara konsep BERBEDA & berbahaya**.

---

### ðŸ§  Detail yang harus lu pegang

Query lu:

```sql
SUM(amount) OVER (
  PARTITION BY customer_id
)
```

Artinya **tanpa ORDER BY**, maka:

* PostgreSQL pakai:

```sql
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

âž¡ï¸ Semua baris dalam partisi dihitung
âž¡ï¸ **Aman**

---

TAPI saat lu nulis:

```sql
SUM(amount) OVER (
  PARTITION BY customer_id
  ORDER BY created_at
)
```

âš ï¸ Default-nya berubah jadi:

```sql
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
```

Bukan ROWS.

Kalau `created_at`:

* unik â†’ hasil mirip
* **tidak unik (tanggal sama)** â†’ hasil **loncat**

ðŸ“Œ **Kesimpulan aturan emas**

> Kalau pakai `ORDER BY` dan MAU total penuh â†’ **WAJIB tulis ROWS eksplisit**

---

## ðŸ§ª KOREKSI JAWABAN LU (Tier 1)

---

### âœ… NOMOR 1 â€” RUNNING TOTAL (BENAR, sedikit dirapikan)

**Jawaban lu:**

```sql
sum(amount) over (
  partition by product 
  order by created_at 
  rows between unbounded preceding and current row
)
```

âœ”ï¸ **BENAR**
âœ”ï¸ Sudah pakai ROWS
âœ”ï¸ Sudah aman dari duplicate date

ðŸ“Œ **Catatan kecil**:
Biasanya running total **per customer atau per time**, bukan per product.
Tapi secara teknis **query lu benar**.

---

### âŒ NOMOR 2 â€” PERSENTASE KONTRIBUSI (KONSEP BENAR, FRAME PERLU DIRAPIKAN)

**Jawaban lu:**

```sql
amount / sum(amount) over(
  partition by customer_id 
  order by created_at 
  rows between unbounded preceding and unbounded following
) * 100
```

### ðŸ”§ Perbaikan penting

`ORDER BY created_at` **TIDAK PERLU** kalau mau total penuh.

Versi **lebih bersih & aman**:

```sql
amount * 100.0
/ SUM(amount) OVER (
  PARTITION BY customer_id
) AS percentage
```

ðŸ“Œ Kenapa?

* Tanpa ORDER BY â†’ default full partition
* Lebih jelas secara niat bisnis
* Lebih sedikit risiko

---

### âš ï¸ NOMOR 3 â€” SLIDING WINDOW (LOGIKA BENAR, NAMA PERLU DILURUSKAN)

**Jawaban lu:**

```sql
ROWS BETWEEN 3 PRECEDING AND CURRENT ROW
```

âš ï¸ Ini artinya:

> â€œBaris ini + **3 baris sebelumnya**â€
> âž¡ï¸ **TOTAL = 4 baris**, bukan 3

ðŸ“Œ Kalau niat lu:

* â€œbaris ini + 2 sebelumnyaâ€ â†’ pakai `2 PRECEDING`
* â€œrolling 4 transaksiâ€ â†’ ini sudah benar

âœ… Query lu **SECARA TEKNIS BENAR**, cuma **label/nama harus akurat**

---

### âš ï¸ NOMOR 4 â€” LAG / DELTA (BENAR, TAPI BOROS)

Query lu **BENAR SECARA LOGIKA**, tapi ada **anti-pattern kecil**:

Lu memanggil `LAG()` **3 kali**.

### ðŸ”§ Versi lebih rapi (BEST PRACTICE)

```sql
WITH base AS (
  SELECT
    id,
    customer_id,
    product,
    amount,
    created_at,
    LAG(amount) OVER (
      PARTITION BY customer_id
      ORDER BY created_at
    ) AS prev_amount
  FROM orders
)
SELECT
  *,
  amount - prev_amount AS delta,
  CASE
    WHEN prev_amount IS NULL THEN 'Tidak Ada'
    WHEN amount > prev_amount THEN 'Naik'
    WHEN amount < prev_amount THEN 'Turun'
    ELSE 'Tetap'
  END AS indikator
FROM base;
```

ðŸ“Œ Lebih:

* efisien
* readable
* production-ready

---

## ðŸ“ CATATAN FINAL (SIAP SIMPAN KE NOTEPAD)

---

### ðŸ¥‡ TIER 1 â€” WINDOW FUNCTION FUNDAMENTAL

---

### **1ï¸âƒ£ Running Total (Cumulative)**

**Kasus:** Total berjalan per customer

```sql
SELECT
  id,
  customer_id,
  amount,
  SUM(amount) OVER (
    PARTITION BY customer_id
    ORDER BY created_at
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS running_total
FROM orders;
```

---

### **2ï¸âƒ£ Total Penuh per Customer (Untuk Persentase)**

```sql
SELECT
  id,
  customer_id,
  amount,
  amount * 100.0
  / SUM(amount) OVER (
    PARTITION BY customer_id
  ) AS percentage
FROM orders;
```

---

### **3ï¸âƒ£ Sliding Window (Rolling N Transaksi)**

**Kasus:** Total transaksi ini + 3 sebelumnya

```sql
SELECT
  id,
  customer_id,
  amount,
  SUM(amount) OVER (
    PARTITION BY customer_id
    ORDER BY created_at
    ROWS BETWEEN 3 PRECEDING AND CURRENT ROW
  ) AS rolling_total
FROM orders;
```

---

### **4ï¸âƒ£ Delta Transaksi (Naik / Turun)**

```sql
WITH base AS (
  SELECT
    id,
    customer_id,
    amount,
    created_at,
    LAG(amount) OVER (
      PARTITION BY customer_id
      ORDER BY created_at
    ) AS prev_amount
  FROM orders
)
SELECT
  *,
  amount - prev_amount AS delta,
  CASE
    WHEN prev_amount IS NULL THEN 'Tidak Ada'
    WHEN amount > prev_amount THEN 'Naik'
    WHEN amount < prev_amount THEN 'Turun'
    ELSE 'Tetap'
  END AS indikator
FROM base;
```
